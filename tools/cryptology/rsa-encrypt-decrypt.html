<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RSA åŠ å¯†/è§£å¯†å·¥å…·</title>
    <!-- å¼•å…¥ Tailwind CSS for styling -->
    <script src="../../vendor/js/tailwind.js"></script>
    <!-- å¼•å…¥ crypto-js for RSA encryption -->
    <script src="../../vendor/js/crypto-js.min.js"></script>
    <!-- å¼•å…¥ JSEncrypt for PKCS#1 v1.5 RSA encryption -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsencrypt/3.3.2/jsencrypt.min.js"></script>
    <!-- å¼•å…¥ Google Fonts -->
    <link href="../../vendor/css/google-fonts.css" rel="stylesheet" />
    <link href="../../css/common.css" rel="stylesheet" />
  </head>
  <body>
    <!-- åŠ¨æ€èƒŒæ™¯ -->
    <div class="background-container">
      <div class="stars"></div>
      <div class="stars2"></div>
      <div class="stars3"></div>
    </div>
    <!-- æ¶ˆæ¯é€šçŸ¥å®¹å™¨ -->
    <div id="notification-container"></div>

    <div class="w-full max-w-7xl mx-auto p-4 sm:p-8 flex flex-col h-screen">
      <header class="text-center mb-6 header-anim">
        <h1
          class="text-3xl sm:text-4xl font-bold text-cyan-400 tech-font"
          style="text-shadow: 0 0 10px rgba(0, 255, 255, 0.5)"
        >
          RSA åŠ å¯†/è§£å¯†
        </h1>
        <p class="text-gray-400 mt-2">ä¸€ä¸ªå…·æœ‰èµ›åšæœ‹å…‹é£æ ¼çš„ RSA åŠ å¯†å·¥å…·ã€‚</p>
      </header>

      <main
        class="main-container main-container-anim flex-grow flex flex-col p-4 sm:p-6"
      >
        <!-- å¯†é’¥è®¾ç½®åŒºåŸŸ -->
        <div class="mb-6">
          <h2 class="text-lg text-cyan-400 tech-font mb-4">å¯†é’¥è®¾ç½®</h2>
          
          <!-- å¯†é’¥ç”Ÿæˆé…ç½® -->
          <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4 p-4 bg-gray-800/30 rounded-lg border border-gray-700">
            <div>
              <label class="block text-sm text-gray-400 mb-2 tech-font">å¯†é’¥é•¿åº¦</label>
              <select id="key-length" class="dark-input w-full p-2 rounded-lg text-sm">
                <option value="512">512 bit</option>
                <option value="1024">1024 bit</option>
                <option value="2048" selected>2048 bit</option>
                <option value="4096">4096 bit</option>
              </select>
            </div>
            <div>
              <label class="block text-sm text-gray-400 mb-2 tech-font">å¯†é’¥æ ¼å¼</label>
              <select id="key-format" class="dark-input w-full p-2 rounded-lg text-sm">
                <option value="pkcs8" selected>PKCS#8</option>
                <option value="pkcs1">PKCS#1</option>
              </select>
            </div>
            <div>
              <label class="block text-sm text-gray-400 mb-2 tech-font">åŠ å¯†æ¨¡å¼</label>
              <select id="encryption-mode" class="dark-input w-full p-2 rounded-lg text-sm">
                <option value="RSA-OAEP" selected>RSA-OAEP (æ¨è)</option>
                <option value="RSA-PKCS1">PKCS#1 v1.5 (å…¼å®¹)</option>
              </select>
            </div>
            <div>
              <label class="block text-sm text-gray-400 mb-2 tech-font">å¯†é’¥å¯†ç  (å¯é€‰)</label>
              <input type="password" id="key-password" class="dark-input w-full p-2 rounded-lg text-sm" placeholder="è¾“å…¥å¯†é’¥ä¿æŠ¤å¯†ç ..." />
            </div>
          </div>
          
          <!-- å¯†é’¥æ“ä½œæŒ‰é’® -->
          <div class="flex flex-wrap gap-4 mb-4 justify-center">
            <button id="generate-keys-btn" class="btn-sci-fi cyan">
              <span class="tech-font">ç”Ÿæˆå¯†é’¥å¯¹</span>
            </button>
            <button id="clear-keys-btn" class="btn-sci-fi red">
              <span class="tech-font">æ¸…ç©ºå¯†é’¥</span>
            </button>
          </div>
          
          <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
            <div class="relative flex flex-col h-full min-h-0">
              <div class="flex justify-between items-center mb-2 px-1">
                <h2 class="text-lg text-cyan-400 tech-font">å…¬é’¥ (Public Key)</h2>
                <button
                  id="copy-public-key-btn"
                  class="text-gray-400 hover:text-white text-xs tech-font"
                >
                  å¤åˆ¶
                </button>
              </div>
              <textarea
                id="public-key"
                rows="4"
                class="dark-textarea w-full p-3 rounded-lg shadow-sm font-mono text-xs"
                placeholder="è¯·è¾“å…¥RSAå…¬é’¥æˆ–ç‚¹å‡»ç”Ÿæˆå¯†é’¥å¯¹..."
              ></textarea>
            </div>
            <div class="relative flex flex-col h-full min-h-0">
              <div class="flex justify-between items-center mb-2 px-1">
                <h2 class="text-lg text-cyan-400 tech-font">ç§é’¥ (Private Key)</h2>
                <button
                  id="copy-private-key-btn"
                  class="text-gray-400 hover:text-white text-xs tech-font"
                >
                  å¤åˆ¶
                </button>
              </div>
              <textarea
                id="private-key"
                rows="4"
                class="dark-textarea w-full p-3 rounded-lg shadow-sm font-mono text-xs"
                placeholder="è¯·è¾“å…¥RSAç§é’¥æˆ–ç‚¹å‡»ç”Ÿæˆå¯†é’¥å¯¹..."
              ></textarea>
            </div>
          </div>
        </div>

        <div class="flex-grow grid grid-cols-1 md:grid-cols-2 gap-4 min-h-0">
          <!-- æ˜æ–‡è¾“å…¥åŒºåŸŸ -->
          <div class="relative flex flex-col h-full min-h-0">
            <div class="flex justify-between items-center mb-2 px-1">
              <h2 class="text-lg text-cyan-400 tech-font">æ˜æ–‡</h2>
              <button
                id="copy-plain-btn"
                class="text-gray-400 hover:text-white text-xs tech-font"
              >
                å¤åˆ¶
              </button>
            </div>
            <textarea
              id="plain-text"
              rows="12"
              class="dark-textarea w-full h-full p-4 rounded-lg shadow-sm font-mono text-sm"
              placeholder="åœ¨æ­¤è¾“å…¥è¦åŠ å¯†çš„å­—ç¬¦ä¸²..."
            ></textarea>
            <div
              id="byte-counter"
              class="absolute bottom-3 right-4 text-xs text-gray-500 tech-font pointer-events-none"
            >
              0 å­—èŠ‚
            </div>
          </div>

          <!-- å¯†æ–‡è¾“å‡ºåŒºåŸŸ -->
          <div class="flex flex-col h-full min-h-0">
            <div class="flex justify-between items-center mb-2 px-1">
              <h2 class="text-lg text-cyan-400 tech-font">å¯†æ–‡</h2>
              <button
                id="copy-cipher-btn"
                class="text-gray-400 hover:text-white text-xs tech-font"
              >
                å¤åˆ¶
              </button>
            </div>
            <textarea
              id="cipher-text"
              rows="12"
              class="dark-textarea w-full h-full p-4 rounded-lg shadow-sm font-mono text-sm"
              placeholder="åœ¨æ­¤è¾“å…¥è¦è§£å¯†çš„å¯†æ–‡å­—ç¬¦ä¸²..."
            ></textarea>
          </div>
        </div>
        <div class="flex flex-wrap gap-4 mt-6 justify-center">
          <button id="encrypt-btn" class="btn-sci-fi green">
            <span class="tech-font">åŠ å¯†</span>
          </button>
          <button id="decrypt-btn" class="btn-sci-fi blue">
            <span class="tech-font">è§£å¯†</span>
          </button>
          <button id="sign-btn" class="btn-sci-fi purple">
            <span class="tech-font">ç­¾å</span>
          </button>
          <button id="verify-btn" class="btn-sci-fi orange">
            <span class="tech-font">éªŒç­¾</span>
          </button>
          <button id="clear-btn" class="btn-sci-fi red">
            <span class="tech-font">æ¸…ç©ºå…¨éƒ¨</span>
          </button>
        </div>
      </main>

      <!-- å…¼å®¹æ€§è¯´æ˜ -->
      <div class="mt-6 p-4 bg-yellow-900/20 border border-yellow-600/30 rounded-lg">
        <h3 class="text-yellow-400 font-semibold mb-2 tech-font">ğŸ”§ åŠŸèƒ½è¯´æ˜</h3>
        <div class="text-sm text-gray-300 space-y-3">
          <div>
            <p><strong>RSAå››ç§æ“ä½œæ¨¡å¼ï¼š</strong></p>
            <ul class="list-disc list-inside space-y-1 ml-4">
              <li><strong>åŠ å¯†ï¼š</strong>ä½¿ç”¨å…¬é’¥åŠ å¯†æ˜æ–‡ï¼Œä¿æŠ¤æ•°æ®æœºå¯†æ€§</li>
              <li><strong>è§£å¯†ï¼š</strong>ä½¿ç”¨ç§é’¥è§£å¯†å¯†æ–‡ï¼Œæ¢å¤åŸå§‹æ•°æ®</li>
              <li><strong>ç­¾åï¼š</strong>ä½¿ç”¨ç§é’¥åŠ å¯†æ˜æ–‡ï¼Œè¯æ˜æ•°æ®æ¥æºå’Œå®Œæ•´æ€§</li>
              <li><strong>éªŒç­¾ï¼š</strong>ä½¿ç”¨å…¬é’¥è§£å¯†å¯†æ–‡ï¼ŒéªŒè¯ç­¾åçš„æœ‰æ•ˆæ€§</li>
            </ul>
          </div>
          
          <div>
            <p><strong>åŠ å¯†æ¨¡å¼ï¼š</strong></p>
            <ul class="list-disc list-inside space-y-1 ml-4">
              <li><strong>RSA-OAEPï¼š</strong>ä½¿ç”¨æµè§ˆå™¨åŸç”ŸWeb Crypto APIï¼Œæ›´å®‰å…¨çš„ç°ä»£åŠ å¯†æ¨¡å¼</li>
              <li><strong>PKCS#1 v1.5ï¼š</strong>ä½¿ç”¨JSEncryptåº“ï¼Œä¼ ç»ŸåŠ å¯†æ¨¡å¼ï¼Œä¸å¤§å¤šæ•°RSAå·¥å…·å…¼å®¹</li>
            </ul>
          </div>
          
          <div>
            <p><strong>é•¿æ–‡æœ¬å¤„ç†ï¼š</strong>PKCS#1 v1.5æ¨¡å¼æ”¯æŒè‡ªåŠ¨åˆ†å—åŠ å¯†/ç­¾åï¼Œå¯å¤„ç†ä»»æ„é•¿åº¦çš„æ–‡æœ¬ã€‚</p>
            <p><strong>æ³¨æ„ï¼š</strong>ä¸¤ç§åŠ å¯†æ¨¡å¼ä¸å…¼å®¹ï¼Œæ‰€æœ‰æ“ä½œå¿…é¡»ä½¿ç”¨ç›¸åŒçš„æ¨¡å¼ã€‚</p>
            <p class="text-yellow-300">ğŸ’¡ <strong>å»ºè®®ï¼š</strong>å¦‚éœ€ä¸å…¶ä»–RSAå·¥å…·ï¼ˆå¦‚OpenSSLï¼‰äº’æ“ä½œï¼Œæ¨èä½¿ç”¨PKCS#1 v1.5æ¨¡å¼ã€‚</p>
          </div>
        </div>
      </div>

      <footer class="text-center mt-8 text-gray-500 text-sm">
        <p>Powered by @AhYi8 âœ¨ &copy; 2024</p>
      </footer>
    </div>

    <script>
      // --- DOM å…ƒç´ è·å– ---
      const plainTextInput = document.getElementById("plain-text");
      const cipherTextInput = document.getElementById("cipher-text");
      const publicKeyInput = document.getElementById("public-key");
      const privateKeyInput = document.getElementById("private-key");
      const copyPlainBtn = document.getElementById("copy-plain-btn");
      const copyCipherBtn = document.getElementById("copy-cipher-btn");
      const copyPublicKeyBtn = document.getElementById("copy-public-key-btn");
      const copyPrivateKeyBtn = document.getElementById("copy-private-key-btn");
      const encryptBtn = document.getElementById("encrypt-btn");
      const decryptBtn = document.getElementById("decrypt-btn");
      const signBtn = document.getElementById("sign-btn");
      const verifyBtn = document.getElementById("verify-btn");
      const clearBtn = document.getElementById("clear-btn");
      const generateKeysBtn = document.getElementById("generate-keys-btn");
      const clearKeysBtn = document.getElementById("clear-keys-btn");
      const keyLengthSelect = document.getElementById("key-length");
      const keyFormatSelect = document.getElementById("key-format");
      const encryptionModeSelect = document.getElementById("encryption-mode");
      const keyPasswordInput = document.getElementById("key-password");
      const notificationContainer = document.getElementById(
        "notification-container"
      );
      const byteCounter = document.getElementById("byte-counter");

      // --- å‡½æ•°å®šä¹‰ ---

      /**
       * æ˜¾ç¤ºæ¶ˆæ¯é€šçŸ¥
       * @param {string} message - è¦æ˜¾ç¤ºçš„æ¶ˆæ¯
       * @param {string} [type='error'] - 'error' æˆ– 'success'
       */
      function showNotification(message, type = "error") {
        const notification = document.createElement("div");
        notification.className = `notification ${type}`;
        notification.textContent = message;
        notificationContainer.appendChild(notification);
        notification.addEventListener("click", () => {
          notification.style.animation = "slideOut 0.5s forwards";
          setTimeout(() => notification.remove(), 500);
        });
        setTimeout(() => {
          if (notification.parentElement) {
            notification.style.animation = "slideOut 0.5s forwards";
            setTimeout(() => notification.remove(), 500);
          }
        }, 3000);
      }

      /**
       * å¤åˆ¶æŒ‡å®šæ–‡æœ¬åˆ°å‰ªè´´æ¿
       * @param {string} textToCopy
       * @param {string} successMessage
       */
      function copyToClipboard(textToCopy, successMessage) {
        if (!textToCopy) {
          showNotification("æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹ã€‚", "error");
          return;
        }

        const tempTextarea = document.createElement("textarea");
        tempTextarea.value = textToCopy;
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        tempTextarea.setSelectionRange(0, 99999);

        try {
          document.execCommand("copy");
          showNotification(successMessage, "success");
        } catch (err) {
          showNotification("å¤åˆ¶å¤±è´¥ã€‚", "error");
          console.error("Copy failed", err);
        }

        document.body.removeChild(tempTextarea);
      }

      /**
       * æ¸…ç©ºæ‰€æœ‰è¾“å…¥æ¡†
       */
      function handleClear() {
        plainTextInput.value = "";
        cipherTextInput.value = "";
        updateByteCounter();
        showNotification("å·²æ¸…ç©ºã€‚", "success");
      }

      /**
       * æ¸…ç©ºå¯†é’¥
       */
      function handleClearKeys() {
        publicKeyInput.value = "";
        privateKeyInput.value = "";
        showNotification("å·²æ¸…ç©ºå¯†é’¥ã€‚", "success");
      }

      /**
       * æ›´æ–°å­—èŠ‚è®¡æ•°å™¨
       */
      function updateByteCounter() {
        const text = plainTextInput.value;
        const byteLength = new Blob([text]).size;
        byteCounter.textContent = `${byteLength} å­—èŠ‚`;
      }

      /**
       * ç”ŸæˆRSAå¯†é’¥å¯¹
       */
      function generateRSAKeys() {
        try {
          const keyLength = parseInt(keyLengthSelect.value);
          const keyFormat = keyFormatSelect.value;
          const encryptionMode = encryptionModeSelect.value;
          const keyPassword = keyPasswordInput.value;
          
          // æ ¹æ®åŠ å¯†æ¨¡å¼é€‰æ‹©ç®—æ³•
          // æ³¨æ„ï¼šå¯¹äºPKCS#1 v1.5ï¼Œæˆ‘ä»¬ä»ç„¶ç”ŸæˆRSA-OAEPå¯†é’¥ï¼Œå› ä¸ºJSEncryptå¯ä»¥å¤„ç†æ ‡å‡†çš„RSAå¯†é’¥
          const algorithm = {
            name: "RSA-OAEP",
            modulusLength: keyLength,
            publicExponent: new Uint8Array([1, 0, 1]),
            hash: "SHA-256",
          };
          
          const keyUsages = ["encrypt", "decrypt"];
          
          // ä½¿ç”¨Web Crypto APIç”ŸæˆRSAå¯†é’¥å¯¹
          window.crypto.subtle.generateKey(
            algorithm,
            true,
            keyUsages
          ).then(async (keyPair) => {
            // å¯¼å‡ºå…¬é’¥
            const publicKey = await window.crypto.subtle.exportKey(
              "spki",
              keyPair.publicKey
            );
            const publicKeyPem = arrayBufferToPem(publicKey, "PUBLIC KEY");
            
            // å¯¼å‡ºç§é’¥
            let privateKeyFormat = "pkcs8";
            if (keyFormat === "pkcs1") {
              // æ³¨æ„ï¼šWeb Crypto APIä¸ç›´æ¥æ”¯æŒPKCS#1æ ¼å¼ï¼Œè¿™é‡Œä»ä½¿ç”¨PKCS#8
              // å®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦é¢å¤–çš„åº“æ¥è½¬æ¢æ ¼å¼
              privateKeyFormat = "pkcs8";
            }
            
            const privateKey = await window.crypto.subtle.exportKey(
              privateKeyFormat,
              keyPair.privateKey
            );
            
            let privateKeyPem;
            if (keyFormat === "pkcs1") {
              // å¯¹äºPKCS#1æ ¼å¼ï¼Œæˆ‘ä»¬éœ€è¦è½¬æ¢æ ‡ç­¾
              privateKeyPem = arrayBufferToPem(privateKey, "RSA PRIVATE KEY");
            } else {
              privateKeyPem = arrayBufferToPem(privateKey, "PRIVATE KEY");
            }
            
            // å¦‚æœè®¾ç½®äº†å¯†ç ï¼Œæ·»åŠ å¯†ç ä¿æŠ¤æç¤ºï¼ˆå®é™…åŠ å¯†éœ€è¦é¢å¤–å®ç°ï¼‰
            if (keyPassword) {
              privateKeyPem += "\n\n// æ³¨æ„ï¼šæ­¤å¯†é’¥æœªåŠ å¯†ï¼Œå¯†ç ä¿æŠ¤åŠŸèƒ½éœ€è¦é¢å¤–å®ç°";
            }
            
            publicKeyInput.value = publicKeyPem;
            privateKeyInput.value = privateKeyPem;
            
            showNotification(`RSA ${keyLength}ä½å¯†é’¥å¯¹ç”ŸæˆæˆåŠŸï¼`, "success");
          }).catch((error) => {
            console.error("Key generation failed:", error);
            showNotification("å¯†é’¥ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æ”¯æŒã€‚", "error");
          });
        } catch (error) {
          console.error("Key generation error:", error);
          showNotification("å¯†é’¥ç”Ÿæˆå¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æ”¯æŒã€‚", "error");
        }
      }

      /**
       * å°†ArrayBufferè½¬æ¢ä¸ºPEMæ ¼å¼
       */
      function arrayBufferToPem(buffer, label) {
        const base64 = btoa(String.fromCharCode(...new Uint8Array(buffer)));
        const formatted = base64.match(/.{1,64}/g).join('\n');
        return `-----BEGIN ${label}-----\n${formatted}\n-----END ${label}-----`;
      }

      /**
       * å°†PEMæ ¼å¼è½¬æ¢ä¸ºArrayBuffer
       */
      function pemToArrayBuffer(pem) {
        const base64 = pem
          .replace(/-----BEGIN [^-]+-----/, '')
          .replace(/-----END [^-]+-----/, '')
          .replace(/\s/g, '');
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
      }

      /**
       * RSAåŠ å¯†ï¼ˆå…¬é’¥åŠ å¯†ï¼‰
       */
      async function handleEncrypt() {
        const plainText = plainTextInput.value;
        const publicKeyPem = publicKeyInput.value;
        const encryptionMode = encryptionModeSelect.value;
        
        if (!plainText) {
          showNotification("è¯·è¾“å…¥è¦åŠ å¯†çš„æ˜æ–‡ã€‚", "error");
          return;
        }
        
        if (!publicKeyPem) {
          showNotification("å…¬é’¥ä¸èƒ½ä¸ºç©ºï¼Œè¯·è¾“å…¥å…¬é’¥æˆ–ç”Ÿæˆå¯†é’¥å¯¹ã€‚", "error");
          return;
        }
        
        try {
          // å¯¼å…¥å…¬é’¥
          const publicKeyBuffer = pemToArrayBuffer(publicKeyPem);
          
          if (encryptionMode === "RSA-PKCS1") {
            // ä½¿ç”¨JSEncryptåº“è¿›è¡ŒPKCS#1 v1.5åŠ å¯†
            try {
              const jsencrypt = new JSEncrypt();
              jsencrypt.setPublicKey(publicKeyPem);
              
              // JSEncryptæœ‰é•¿åº¦é™åˆ¶ï¼Œéœ€è¦åˆ†å—åŠ å¯†
              const maxLength = 117; // å¯¹äº1024ä½å¯†é’¥ï¼Œæœ€å¤§æ˜æ–‡é•¿åº¦çº¦ä¸º117å­—èŠ‚
              let encryptedText = '';
              
              if (plainText.length <= maxLength) {
                // çŸ­æ–‡æœ¬ç›´æ¥åŠ å¯†
                encryptedText = jsencrypt.encrypt(plainText);
              } else {
                // é•¿æ–‡æœ¬åˆ†å—åŠ å¯†
                for (let i = 0; i < plainText.length; i += maxLength) {
                  const chunk = plainText.substring(i, i + maxLength);
                  const encryptedChunk = jsencrypt.encrypt(chunk);
                  if (!encryptedChunk) {
                    throw new Error('åŠ å¯†å¤±è´¥ï¼Œå¯èƒ½æ˜¯æ˜æ–‡è¿‡é•¿æˆ–å¯†é’¥æ ¼å¼é”™è¯¯');
                  }
                  encryptedText += encryptedChunk + '|';
                }
                // ç§»é™¤æœ€åä¸€ä¸ªåˆ†éš”ç¬¦
                encryptedText = encryptedText.slice(0, -1);
              }
              
              if (!encryptedText) {
                throw new Error('åŠ å¯†å¤±è´¥ï¼Œè¯·æ£€æŸ¥å…¬é’¥æ ¼å¼');
              }
              
              cipherTextInput.value = encryptedText;
              showNotification("PKCS#1 v1.5åŠ å¯†æˆåŠŸï¼", "success");
              return;
            } catch (error) {
              console.error("PKCS#1 v1.5 encryption failed:", error);
              showNotification("PKCS#1 v1.5åŠ å¯†å¤±è´¥ï¼š" + error.message, "error");
              return;
            }
          }
          
          const publicKey = await window.crypto.subtle.importKey(
            "spki",
            publicKeyBuffer,
            {
              name: "RSA-OAEP",
              hash: "SHA-256",
            },
            false,
            ["encrypt"]
          );
          
          // åŠ å¯†
          const encoder = new TextEncoder();
          const data = encoder.encode(plainText);
          const encrypted = await window.crypto.subtle.encrypt(
            {
              name: "RSA-OAEP",
            },
            publicKey,
            data
          );
          
          // è½¬æ¢ä¸ºBase64
          const encryptedBase64 = btoa(String.fromCharCode(...new Uint8Array(encrypted)));
          cipherTextInput.value = encryptedBase64;
          
          showNotification("åŠ å¯†æˆåŠŸï¼", "success");
        } catch (error) {
          console.error("Encryption failed:", error);
          showNotification("åŠ å¯†å¤±è´¥ï¼Œè¯·æ£€æŸ¥å…¬é’¥æ ¼å¼ã€‚", "error");
        }
      }

      /**
       * RSAè§£å¯†ï¼ˆç§é’¥è§£å¯†ï¼‰
       */
      async function handleDecrypt() {
        const cipherText = cipherTextInput.value;
        const privateKeyPem = privateKeyInput.value;
        const encryptionMode = encryptionModeSelect.value;
        
        if (!cipherText) {
          showNotification("è¯·è¾“å…¥è¦è§£å¯†çš„å¯†æ–‡ã€‚", "error");
          return;
        }
        
        if (!privateKeyPem) {
          showNotification("ç§é’¥ä¸èƒ½ä¸ºç©ºï¼Œè¯·è¾“å…¥ç§é’¥æˆ–ç”Ÿæˆå¯†é’¥å¯¹ã€‚", "error");
          return;
        }
        
        try {
          // å¯¼å…¥ç§é’¥
          const privateKeyBuffer = pemToArrayBuffer(privateKeyPem);
          
          if (encryptionMode === "RSA-PKCS1") {
            // ä½¿ç”¨JSEncryptåº“è¿›è¡ŒPKCS#1 v1.5è§£å¯†
            try {
              const jsencrypt = new JSEncrypt();
              jsencrypt.setPrivateKey(privateKeyPem);
              
              let decryptedText = '';
              
              // æ£€æŸ¥æ˜¯å¦æ˜¯åˆ†å—åŠ å¯†çš„å¯†æ–‡ï¼ˆåŒ…å«|åˆ†éš”ç¬¦ï¼‰
              if (cipherText.includes('|')) {
                // åˆ†å—è§£å¯†
                const encryptedChunks = cipherText.split('|');
                for (const chunk of encryptedChunks) {
                  const decryptedChunk = jsencrypt.decrypt(chunk);
                  if (decryptedChunk === false) {
                    throw new Error('è§£å¯†å¤±è´¥ï¼Œå¯èƒ½æ˜¯ç§é’¥æ ¼å¼é”™è¯¯æˆ–å¯†æ–‡æŸå');
                  }
                  decryptedText += decryptedChunk;
                }
              } else {
                // å•å—è§£å¯†
                decryptedText = jsencrypt.decrypt(cipherText);
                if (decryptedText === false) {
                  throw new Error('è§£å¯†å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç§é’¥æ ¼å¼å’Œå¯†æ–‡');
                }
              }
              
              plainTextInput.value = decryptedText;
              updateByteCounter();
              showNotification("PKCS#1 v1.5è§£å¯†æˆåŠŸï¼", "success");
              return;
            } catch (error) {
              console.error("PKCS#1 v1.5 decryption failed:", error);
              showNotification("PKCS#1 v1.5è§£å¯†å¤±è´¥ï¼š" + error.message, "error");
              return;
            }
          }
          
          const privateKey = await window.crypto.subtle.importKey(
            "pkcs8",
            privateKeyBuffer,
            {
              name: "RSA-OAEP",
              hash: "SHA-256",
            },
            false,
            ["decrypt"]
          );
          
          // è§£å¯†
          const encryptedData = Uint8Array.from(atob(cipherText), c => c.charCodeAt(0));
          const decrypted = await window.crypto.subtle.decrypt(
            {
              name: "RSA-OAEP",
            },
            privateKey,
            encryptedData
          );
          
          // è½¬æ¢ä¸ºæ–‡æœ¬
          const decoder = new TextDecoder();
          const decryptedText = decoder.decode(decrypted);
          plainTextInput.value = decryptedText;
          updateByteCounter();
          
          showNotification("è§£å¯†æˆåŠŸï¼", "success");
        } catch (error) {
          console.error("Decryption failed:", error);
          showNotification("è§£å¯†å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç§é’¥æ ¼å¼å’Œå¯†æ–‡ã€‚", "error");
        }
      }

      /**
       * RSAç­¾åï¼ˆç§é’¥åŠ å¯†ï¼‰
       */
      async function handleSign() {
        const plainText = plainTextInput.value;
        const privateKeyPem = privateKeyInput.value;
        const encryptionMode = encryptionModeSelect.value;
        
        if (!plainText) {
          showNotification("è¯·è¾“å…¥è¦ç­¾åçš„æ˜æ–‡ã€‚", "error");
          return;
        }
        
        if (!privateKeyPem) {
          showNotification("ç§é’¥ä¸èƒ½ä¸ºç©ºï¼Œè¯·è¾“å…¥ç§é’¥æˆ–ç”Ÿæˆå¯†é’¥å¯¹ã€‚", "error");
          return;
        }
        
        try {
          // å¯¼å…¥ç§é’¥
          const privateKeyBuffer = pemToArrayBuffer(privateKeyPem);
          
          if (encryptionMode === "RSA-PKCS1") {
            // ä½¿ç”¨JSEncryptåº“è¿›è¡ŒPKCS#1 v1.5ç­¾åï¼ˆç§é’¥åŠ å¯†ï¼‰
            try {
              const jsencrypt = new JSEncrypt();
              jsencrypt.setPrivateKey(privateKeyPem);
              
              // JSEncryptæœ‰é•¿åº¦é™åˆ¶ï¼Œéœ€è¦åˆ†å—åŠ å¯†
              const maxLength = 117; // å¯¹äº1024ä½å¯†é’¥ï¼Œæœ€å¤§æ˜æ–‡é•¿åº¦çº¦ä¸º117å­—èŠ‚
              let signedText = '';
              
              if (plainText.length <= maxLength) {
                // çŸ­æ–‡æœ¬ç›´æ¥ç­¾å
                signedText = jsencrypt.encrypt(plainText);
              } else {
                // é•¿æ–‡æœ¬åˆ†å—ç­¾å
                for (let i = 0; i < plainText.length; i += maxLength) {
                  const chunk = plainText.substring(i, i + maxLength);
                  const signedChunk = jsencrypt.encrypt(chunk);
                  if (!signedChunk) {
                    throw new Error('ç­¾åå¤±è´¥ï¼Œå¯èƒ½æ˜¯æ˜æ–‡è¿‡é•¿æˆ–ç§é’¥æ ¼å¼é”™è¯¯');
                  }
                  signedText += signedChunk + '|';
                }
                // ç§»é™¤æœ€åä¸€ä¸ªåˆ†éš”ç¬¦
                signedText = signedText.slice(0, -1);
              }
              
              if (!signedText) {
                throw new Error('ç­¾åå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç§é’¥æ ¼å¼');
              }
              
              cipherTextInput.value = signedText;
              showNotification("PKCS#1 v1.5ç­¾åæˆåŠŸï¼", "success");
              return;
            } catch (error) {
              console.error("PKCS#1 v1.5 signing failed:", error);
              showNotification("PKCS#1 v1.5ç­¾åå¤±è´¥ï¼š" + error.message, "error");
              return;
            }
          }
          
          const privateKey = await window.crypto.subtle.importKey(
            "pkcs8",
            privateKeyBuffer,
            {
              name: "RSA-OAEP",
              hash: "SHA-256",
            },
            false,
            ["encrypt"]
          );
          
          // ç­¾åï¼ˆç§é’¥åŠ å¯†ï¼‰
          const encoder = new TextEncoder();
          const data = encoder.encode(plainText);
          const signed = await window.crypto.subtle.encrypt(
            {
              name: "RSA-OAEP",
            },
            privateKey,
            data
          );
          
          // è½¬æ¢ä¸ºBase64
          const signedBase64 = btoa(String.fromCharCode(...new Uint8Array(signed)));
          cipherTextInput.value = signedBase64;
          
          showNotification("ç­¾åæˆåŠŸï¼", "success");
        } catch (error) {
          console.error("Signing failed:", error);
          showNotification("ç­¾åå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç§é’¥æ ¼å¼ã€‚", "error");
        }
      }

      /**
       * RSAéªŒç­¾ï¼ˆå…¬é’¥è§£å¯†ï¼‰
       */
      async function handleVerify() {
        const cipherText = cipherTextInput.value;
        const publicKeyPem = publicKeyInput.value;
        const encryptionMode = encryptionModeSelect.value;
        
        if (!cipherText) {
          showNotification("è¯·è¾“å…¥è¦éªŒç­¾çš„å¯†æ–‡ã€‚", "error");
          return;
        }
        
        if (!publicKeyPem) {
          showNotification("å…¬é’¥ä¸èƒ½ä¸ºç©ºï¼Œè¯·è¾“å…¥å…¬é’¥æˆ–ç”Ÿæˆå¯†é’¥å¯¹ã€‚", "error");
          return;
        }
        
        try {
          // å¯¼å…¥å…¬é’¥
          const publicKeyBuffer = pemToArrayBuffer(publicKeyPem);
          
          if (encryptionMode === "RSA-PKCS1") {
            // ä½¿ç”¨JSEncryptåº“è¿›è¡ŒPKCS#1 v1.5éªŒç­¾ï¼ˆå…¬é’¥è§£å¯†ï¼‰
            try {
              const jsencrypt = new JSEncrypt();
              jsencrypt.setPublicKey(publicKeyPem);
              
              let verifiedText = '';
              
              // æ£€æŸ¥æ˜¯å¦æ˜¯åˆ†å—ç­¾åçš„å¯†æ–‡ï¼ˆåŒ…å«|åˆ†éš”ç¬¦ï¼‰
              if (cipherText.includes('|')) {
                // åˆ†å—éªŒç­¾
                const signedChunks = cipherText.split('|');
                for (const chunk of signedChunks) {
                  const verifiedChunk = jsencrypt.decrypt(chunk);
                  if (verifiedChunk === false) {
                    throw new Error('éªŒç­¾å¤±è´¥ï¼Œå¯èƒ½æ˜¯å…¬é’¥æ ¼å¼é”™è¯¯æˆ–å¯†æ–‡æŸå');
                  }
                  verifiedText += verifiedChunk;
                }
              } else {
                // å•å—éªŒç­¾
                verifiedText = jsencrypt.decrypt(cipherText);
                if (verifiedText === false) {
                  throw new Error('éªŒç­¾å¤±è´¥ï¼Œè¯·æ£€æŸ¥å…¬é’¥æ ¼å¼å’Œå¯†æ–‡');
                }
              }
              
              plainTextInput.value = verifiedText;
              updateByteCounter();
              showNotification("PKCS#1 v1.5éªŒç­¾æˆåŠŸï¼", "success");
              return;
            } catch (error) {
              console.error("PKCS#1 v1.5 verification failed:", error);
              showNotification("PKCS#1 v1.5éªŒç­¾å¤±è´¥ï¼š" + error.message, "error");
              return;
            }
          }
          
          const publicKey = await window.crypto.subtle.importKey(
            "spki",
            publicKeyBuffer,
            {
              name: "RSA-OAEP",
              hash: "SHA-256",
            },
            false,
            ["decrypt"]
          );
          
          // éªŒç­¾ï¼ˆå…¬é’¥è§£å¯†ï¼‰
          const signedData = Uint8Array.from(atob(cipherText), c => c.charCodeAt(0));
          const verified = await window.crypto.subtle.decrypt(
            {
              name: "RSA-OAEP",
            },
            publicKey,
            signedData
          );
          
          // è½¬æ¢ä¸ºæ–‡æœ¬
          const decoder = new TextDecoder();
          const verifiedText = decoder.decode(verified);
          plainTextInput.value = verifiedText;
          updateByteCounter();
          
          showNotification("éªŒç­¾æˆåŠŸï¼", "success");
        } catch (error) {
          console.error("Verification failed:", error);
          showNotification("éªŒç­¾å¤±è´¥ï¼Œè¯·æ£€æŸ¥å…¬é’¥æ ¼å¼å’Œå¯†æ–‡ã€‚", "error");
        }
      }

      // --- äº‹ä»¶ç›‘å¬ ---
      copyPlainBtn.addEventListener("click", () =>
        copyToClipboard(plainTextInput.value, "å·²å¤åˆ¶æ˜æ–‡ï¼")
      );
      copyCipherBtn.addEventListener("click", () =>
        copyToClipboard(cipherTextInput.value, "å·²å¤åˆ¶å¯†æ–‡ï¼")
      );
      copyPublicKeyBtn.addEventListener("click", () =>
        copyToClipboard(publicKeyInput.value, "å·²å¤åˆ¶å…¬é’¥ï¼")
      );
      copyPrivateKeyBtn.addEventListener("click", () =>
        copyToClipboard(privateKeyInput.value, "å·²å¤åˆ¶ç§é’¥ï¼")
      );
      clearBtn.addEventListener("click", handleClear);
      clearKeysBtn.addEventListener("click", handleClearKeys);
      generateKeysBtn.addEventListener("click", generateRSAKeys);
      encryptBtn.addEventListener("click", handleEncrypt);
      decryptBtn.addEventListener("click", handleDecrypt);
      signBtn.addEventListener("click", handleSign);
      verifyBtn.addEventListener("click", handleVerify);

      plainTextInput.addEventListener("input", updateByteCounter);
    </script>
  </body>
</html>